<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - postprocessing - afterimage pass</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.1/mapbox-gl.js'></script>
	<link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.1/mapbox-gl.css' rel='stylesheet' />
	<script src='https://unpkg.com/three@0.117.1/build/three.min.js'></script>
	<script src="https://unpkg.com/three@0.117.1/examples/js/shaders/AfterimageShader"></script>
	<script src="https://unpkg.com/three@0.117.1/examples/js/postprocessing/EffectComposer"></script>
	<script src="https://unpkg.com/three@0.117.1/examples/js/postprocessing/ShaderPass"></script>
	<script src="https://unpkg.com/three@0.117.1/examples/js/postprocessing/RenderPass"></script>
	<script src="https://unpkg.com/three@0.117.1/examples/js/postprocessing/AfterimagePass"></script>
	<style>
		body {
			margin: 0;
			padding: 0;
		}

		#map {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 100%;
		}
	</style>
</head>
<body>

	<div id="map"></div>
	<script type="module">
		// add custom layer
		mapboxgl.accessToken = 'pk.eyJ1IjoiY2F0bnVrbyIsImEiOiJja2MwMDUxc2Iwa2RjMnFxcWk4c2cwcjQ5In0.VlIEyCroRFIp67cwUWLz1Q';
		let map = new mapboxgl.Map({
			container: 'map',
			style: 'mapbox://styles/mapbox/light-v10',
			zoom: 16,
			center: [-122.3491, 47.6207],
			pitch: 60,
			antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
		});
		let modelOrigin = [-122.3491, 47.6207, 0];
		let modelAltitude = 100;
		let modelRotate = [Math.PI / 2, 0, 0];
		let modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(modelOrigin, modelAltitude);
		// transformation parameters to position, rotate and scale the 3D model onto the map
		let modelTransform = {
			translateX: modelAsMercatorCoordinate.x,
			translateY: modelAsMercatorCoordinate.y,
			translateZ: modelAsMercatorCoordinate.z,
			rotateX: modelRotate[0],
			rotateY: modelRotate[1],
			rotateZ: modelRotate[2],
			/* Since our 3D model is in real world meters, a scale transform needs to be
			* applied since the CustomLayerInterface expects units in MercatorCoordinates.
			*/
			scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
		};

		let composer, cube;
		let params = {
			enable: true
		};

		let THREE = window.THREE;

		let customLayer = {
			id: '3d-model',
			type: 'custom',
			renderingMode: '3d',
			onAdd: function (map, gl) {
				this.camera = new THREE.Camera();
				this.scene = new THREE.Scene();
				this.map = map;
				let ambientLight = new THREE.AmbientLight(0xffffff);
				this.scene.add(ambientLight);
				let geometry = new THREE.BoxBufferGeometry(50, 50, 50, 2, 2, 2);
				let material = new THREE.MeshNormalMaterial();
				cube = new THREE.Mesh(geometry, material);
				this.scene.add(cube);
				this.map = map;

				// use the Mapbox GL JS map canvas for three.js
				this.renderer = new THREE.WebGLRenderer({
					canvas: map.getCanvas(),
					context: gl,
					antialias: true,
					preserveDrawingBuffer: false
				});

				this.renderer.autoClear = false;

				// add EffectComposer
				composer = new THREE.EffectComposer(this.renderer);
				composer.addPass(new THREE.RenderPass(this.scene, this.camera));

				const ap = new THREE.AfterimagePass();
				ap._realRender = ap.render;
				ap.render = function (renderer) {
					renderer.setRenderTarget(this.textureComp);
					renderer.clear();
					this._realRender.apply(this, arguments);
				}
				composer.addPass(ap);
			},
			render: function (gl, matrix) {
				let rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), modelTransform.rotateX);
				let rotationY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), modelTransform.rotateY);
				let rotationZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), modelTransform.rotateZ);

				let m = new THREE.Matrix4().fromArray(matrix);
				let l = new THREE.Matrix4().makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)
					.scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))
					.multiply(rotationX)
					.multiply(rotationY)
					.multiply(rotationZ);

				this.camera.projectionMatrix = m.multiply(l);
				this.renderer.state.reset();

				cube.rotation.x += 0.005;
				cube.rotation.y += 0.01;

				// use composer
				composer.render();

				this.map.triggerRepaint();
			}
		};

		map.on('style.load', function () {
			map.addLayer(customLayer);
		});

	</script>

</body>

</html>